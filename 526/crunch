#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2013-2014 Martin Ueding <dev@martin-ueding.de>
# Licensed under The GNU Public License Version 2 (or later)

import json
import sys

import matplotlib.pyplot as pl
import numpy as np
import scipy.optimize as op
import scipy.misc
import matplotlib.pyplot as pl
import scipy.ndimage.filters
import unitprint

def gauss(x, mean, sigma, a):
    return a / np.sqrt(sigma) * np.exp(- ((x - mean)/sigma)**2)

def extract_photo_peak(filename, dicke_mm):
    normal_data = np.loadtxt('Daten/01_Untergrund001.txt')
    normal_counts = normal_data[:, 1]
    data = np.loadtxt(filename)
    bins = data[:, 0]
    counts = data[:, 1]

    sigma = 50

    normal_counts = scipy.ndimage.filters.gaussian_filter(normal_counts, sigma)
    counts = scipy.ndimage.filters.gaussian_filter(counts, sigma)
    counts /= normal_counts

    counts_err = np.sqrt(
        (np.sqrt(counts) / normal_counts)**2
        + (counts / normal_counts**2 * np.sqrt(normal_counts))**2
    )

    lower = 200
    upper = -1

    bins = bins[lower:upper]
    counts = counts[lower:upper]
    counts_err = counts_err[lower:upper]

    mean = np.mean(counts)
    print(mean)

    pl.errorbar(bins, counts, yerr=counts_err)
    pl.plot(bins, np.ones(counts.shape) * np.mean(counts))

def extinction_ratio(filename, dicke_mm):
    normal_data = np.loadtxt('Daten/01_Untergrund001.txt')
    normal_counts = normal_data[:, 1]
    data = np.loadtxt(filename)
    bins = data[:, 0]
    counts = data[:, 1]

    sigma = 50

    normal_counts = scipy.ndimage.filters.gaussian_filter(normal_counts, sigma)
    counts = scipy.ndimage.filters.gaussian_filter(counts, sigma)
    counts /= normal_counts

    counts_err = np.sqrt(
        (np.sqrt(counts) / normal_counts)**2
        + (counts / normal_counts**2 * np.sqrt(normal_counts))**2
    )

    lower = 200
    upper = -1
    step = len(bins[lower:upper]) // 200

    bins = bins[lower:upper:step]
    counts = counts[lower:upper:step]
    counts_err = counts_err[lower:upper:step]

    np.savetxt('_build/plot-ratio-{:02d}mm.txt'.format(dicke_mm), np.column_stack([
        bins, counts, counts_err
    ]))

def absorption(T):
    extinction_ratio('Daten/01_Untergrund001.txt', 0)
    extinction_ratio('Daten/1mm_Al_0deg001.txt', 1)
    extinction_ratio('Daten/5mm_Al_0deg001.txt', 5)
    extinction_ratio('Daten/10mm_Al_0deg001.txt', 10)
    extinction_ratio('Daten/20mm_Al_0deg001.txt', 20)
    extinction_ratio('Daten/50mm_Al_0deg001.txt', 50)


    if False:
        points = []
        points.append(extract_photo_peak('Daten/01_Untergrund001.txt', 0))
        points.append(extract_photo_peak('Daten/1mm_Al_0deg001.txt', 1))
        points.append(extract_photo_peak('Daten/5mm_Al_0deg001.txt', 5))
        points.append(extract_photo_peak('Daten/10mm_Al_0deg001.txt', 10))
        points.append(extract_photo_peak('Daten/20mm_Al_0deg001.txt', 20))
        points.append(extract_photo_peak('Daten/50mm_Al_0deg001.txt', 50))

        pl.grid(True)
        pl.show()



def sigma_omega_klein_nishina(gamma, theta):
    re = 1e-15

    cos = np.cos(theta)

    return re**2 / 2 \
            * \
            1 / (1 + gamma * (1 - cos))**2 \
            * \
            (1 + cos**2 + (gamma**2 * (1 - cos)**2) / (1 + gamma * (1 - cos)))


def task_nishina_theorie(T):
    theta = np.linspace(0, np.pi, 1000)

    sigma_omega = sigma_omega_klein_nishina(0.01, theta)
    np.savetxt('_build/plot_klein_nishina_1.txt',
               np.column_stack([np.degrees(theta), sigma_omega]))

    sigma_omega = sigma_omega_klein_nishina(0.1, theta)
    np.savetxt('_build/plot_klein_nishina_2.txt',
               np.column_stack([np.degrees(theta), sigma_omega]))

    sigma_omega = sigma_omega_klein_nishina(1, theta)
    np.savetxt('_build/plot_klein_nishina_3.txt',
               np.column_stack([np.degrees(theta), sigma_omega]))

    sigma_omega = sigma_omega_klein_nishina(10, theta)
    np.savetxt('_build/plot_klein_nishina_4.txt',
               np.column_stack([np.degrees(theta), sigma_omega]))

def test_keys(T):
    dash_keys = []
    for key in T:
        if '-' in key:
            dash_keys.append(key)

    if len(dash_keys) > 0:
        print()
        print('**************************************************************')
        print('* Es dürfen keine Bindestriche in den Schlüsseln für T sein! *')
        print('**************************************************************')
        print()
        print('Folgende Schlüssel enthalten Bindestriche:')
        for dash_key in dash_keys:
            print('-', dash_key)
        print()
        sys.exit(100)


def main():
    T = {}

    task_nishina_theorie(T)
    absorption(T)


    test_keys(T)
    with open('_build/template.js', 'w') as f:
        json.dump(dict(T), f, indent=4, sort_keys=True)

if __name__ == "__main__":
    main()
