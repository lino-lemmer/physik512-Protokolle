#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2013-2014 Martin Ueding <dev@martin-ueding.de>
# Licensed under The GNU Public License Version 2 (or later)

import json
import sys

import matplotlib.pyplot as pl
import numpy as np
import scipy.optimize as op
import scipy.misc
import scipy.stats
import matplotlib.pyplot as pl
import scipy.ndimage.filters
import unitprint

def gauss(x, mean, sigma, a):
    return a / sigma * np.exp(- ((x - mean)/sigma)**2)

def decay(x, tau, a):
    return a * np.exp(- x / tau)

def extract_photo_peak(filename, dicke_mm):
    data = np.loadtxt(filename)
    bins = data[:, 0]
    counts = data[:, 1]

    lower = 200
    upper = -1
    step = len(bins[lower:upper]) // 200

    bins = bins[lower:upper]
    counts = counts[lower:upper]

    lower_fit = 2700
    upper_fit = -1

    popt, pconv = op.curve_fit(
        gauss,
        bins[lower_fit:upper_fit],
        counts[lower_fit:upper_fit], 
        p0=[3000, 100, 120000],
    )

    y = gauss(bins, *popt)

    chisq, p = scipy.stats.chisquare(
        counts[lower_fit:upper_fit],
        y[lower_fit:upper_fit]
    )
    divisor = len(counts[lower_fit:upper_fit]) - 3 - 1

    np.savetxt('_build/plot-decay-data-{:02d}mm.txt'.format(dicke_mm), np.column_stack([
        bins, counts
    ]))
    np.savetxt('_build/plot-decay-used-{:02d}mm.txt'.format(dicke_mm), np.column_stack([
        bins[lower_fit:upper_fit], counts[lower_fit:upper_fit]
    ]))
    np.savetxt('_build/plot-decay-fit-{:02d}mm.txt'.format(dicke_mm), np.column_stack([
        bins[lower_fit:upper_fit], y[lower_fit:upper_fit]
    ]))

    return dicke_mm, popt[2], np.sqrt(pconv.diagonal())[2]


    #pl.plot(bins, counts)
    #pl.plot(bins, y)
    #pl.show()


def extinction_ratio(filename, dicke_mm):
    normal_data = np.loadtxt('Daten/01_Untergrund001.txt')
    normal_counts = normal_data[:, 1]
    data = np.loadtxt(filename)
    bins = data[:, 0]
    counts = data[:, 1]

    sigma = 50

    normal_counts = scipy.ndimage.filters.gaussian_filter(normal_counts, sigma)
    counts = scipy.ndimage.filters.gaussian_filter(counts, sigma)
    counts /= normal_counts

    counts_err = np.sqrt(
        (np.sqrt(counts) / normal_counts)**2
        + (counts / normal_counts**2 * np.sqrt(normal_counts))**2
    )

    lower = 200
    upper = -1
    step = len(bins[lower:upper]) // 200

    bins = bins[lower:upper:step]
    counts = counts[lower:upper:step]
    counts_err = counts_err[lower:upper:step]

    np.savetxt('_build/plot-ratio-{:02d}mm.txt'.format(dicke_mm), np.column_stack([
        bins, counts, counts_err
    ]))

def absorption(T):
    extinction_ratio('Daten/01_Untergrund001.txt', 0)
    extinction_ratio('Daten/1mm_Al_0deg001.txt', 1)
    extinction_ratio('Daten/5mm_Al_0deg001.txt', 5)
    extinction_ratio('Daten/10mm_Al_0deg001.txt', 10)
    extinction_ratio('Daten/20mm_Al_0deg001.txt', 20)
    extinction_ratio('Daten/50mm_Al_0deg001.txt', 50)

    points = []
    points.append(extract_photo_peak('Daten/01_Untergrund001.txt', 0))
    points.append(extract_photo_peak('Daten/1mm_Al_0deg001.txt', 1))
    points.append(extract_photo_peak('Daten/5mm_Al_0deg001.txt', 5))
    points.append(extract_photo_peak('Daten/10mm_Al_0deg001.txt', 10))
    points.append(extract_photo_peak('Daten/20mm_Al_0deg001.txt', 20))
    points.append(extract_photo_peak('Daten/50mm_Al_0deg001.txt', 50))

    points = np.array(points)


    dicke = points[:, 0]
    ampl_val = points[:, 1]
    ampl_err = points[:, 2]

    popt, pconv = op.curve_fit(
        decay,
        dicke, ampl_val,
        p0=[20, 420000],
        sigma=ampl_err,
    )
    print(popt)
    print(pconv)
    x = np.linspace(np.min(dicke), np.max(dicke), 100)
    y = decay(x, *popt)
    

    pl.errorbar(dicke, ampl_val, ampl_err)
    pl.plot(x, y)
    #pl.show()



def sigma_omega_klein_nishina(gamma, theta):
    re = 1e-15

    cos = np.cos(theta)

    return re**2 / 2 \
            * \
            1 / (1 + gamma * (1 - cos))**2 \
            * \
            (1 + cos**2 + (gamma**2 * (1 - cos)**2) / (1 + gamma * (1 - cos)))


def task_nishina_theorie(T):
    theta = np.linspace(0, np.pi, 1000)

    sigma_omega = sigma_omega_klein_nishina(0.01, theta)
    np.savetxt('_build/plot_klein_nishina_1.txt',
               np.column_stack([np.degrees(theta), sigma_omega]))

    sigma_omega = sigma_omega_klein_nishina(0.1, theta)
    np.savetxt('_build/plot_klein_nishina_2.txt',
               np.column_stack([np.degrees(theta), sigma_omega]))

    sigma_omega = sigma_omega_klein_nishina(1, theta)
    np.savetxt('_build/plot_klein_nishina_3.txt',
               np.column_stack([np.degrees(theta), sigma_omega]))

    sigma_omega = sigma_omega_klein_nishina(10, theta)
    np.savetxt('_build/plot_klein_nishina_4.txt',
               np.column_stack([np.degrees(theta), sigma_omega]))

def test_keys(T):
    dash_keys = []
    for key in T:
        if '-' in key:
            dash_keys.append(key)

    if len(dash_keys) > 0:
        print()
        print('**************************************************************')
        print('* Es dürfen keine Bindestriche in den Schlüsseln für T sein! *')
        print('**************************************************************')
        print()
        print('Folgende Schlüssel enthalten Bindestriche:')
        for dash_key in dash_keys:
            print('-', dash_key)
        print()
        sys.exit(100)


def main():
    T = {}

    task_nishina_theorie(T)
    absorption(T)


    test_keys(T)
    with open('_build/template.js', 'w') as f:
        json.dump(dict(T), f, indent=4, sort_keys=True)

if __name__ == "__main__":
    main()
